# Sliding Window problem patterns (Memorize)


Hereâ€™s a **one-page sliding window cheat sheet** with all the major patterns and visual examples so itâ€™s easy to remember.

---

# ğŸŸ¢ **Sliding Window Cheat Sheet**


1. **Fixed-Size Window** â†’ Window size = constant `k`

   * Common operations inside the window:

     * **Sum / Average** â†’ numeric problems
     * **Frequency / Count** â†’ letters, characters, or numbers
     * **Max / Min** â†’ can use deque for efficiency
     * **Prefix Sum** â†’ Precompute cumulative sums so that you can answer range sum queries in O(1) time.

2. **Dynamic-Size (Variable) Window** â†’ Window expands or shrinks based on a **condition**

   * Common operations:

     * **Max / Min** â†’ find longest/shortest satisfying condition
     * **Frequency / Count** â†’ distinct characters, repeating elements
     * **Sum / Product** â†’ sliding sum/product with target constraints
     * **Prefix Sum** â†’ Precompute cumulative sums so that you can answer range sum queries in O(1) time.

---

âœ… **Memory Trick:**

> â€œFixed â†’ just slide & compute, Dynamic â†’ expand/shrink & maintain conditionâ€

---


## **Detailed explanation:**

## **1ï¸âƒ£ Fixed-Size Window**

**Pattern:** Slide a window of size `k` across array/string.

![alt text](image.png)

**Visual:**

```
Array: [1, 3, 2, 5, 4] , k=3
Window: [1,3,2] -> sum=6
Slide â†’ [3,2,5] -> sum=10
Slide â†’ [2,5,4] -> sum=11
```

**Use Cases:**

* Max/Min in subarray of size k
* Sum/Average of subarrays
* Detect patterns in substrings

---

## **2ï¸âƒ£ Dynamic-Size Window**

**Pattern:** Window grows/shrinks until condition is satisfied.

**Visual:**

```
Array: [2,1,5,2,3,2], target_sum â‰¥ 7

Start: left=0, right=0, sum=0
Add 2 â†’ sum=2
Add 1 â†’ sum=3
Add 5 â†’ sum=8 âœ… condition met, shrink from left
Remove 2 â†’ sum=6 âŒ condition fails, expand right
...
```

**Use Cases:**

* Smallest subarray with sum â‰¥ S
* Longest substring with â‰¤ K distinct chars
* Subarray with sum divisible by k

---

## **3ï¸âƒ£ Frequency / Count Map**

**Pattern:** Maintain frequency of elements inside window.

**Visual:**

```
String: "cbaebabacd", pattern="abc", k=3

Window "cba" â†’ freq={'a':1,'b':1,'c':1} âœ… matches pattern
Slide â†’ "bae" â†’ freq={'b':1,'a':1,'e':1} âŒ
```

**Use Cases:**

* Count anagrams of a pattern
* Substrings with exact k distinct chars
* Sliding substring problems

---

## **4ï¸âƒ£ Max/Min Tracking (Deque)**

**Pattern:** Track max/min efficiently using deque.

**Visual:**

```
Array: [1,3,-1,-3,5,3,6,7], k=3

Max in each window:
[1,3,-1] â†’ 3
[3,-1,-3] â†’ 3
[-1,-3,5] â†’ 5
```

**Use Cases:**

* Sliding window maximum/minimum
* Monotonic queue problems

---

## **5ï¸âƒ£ Boolean / Condition Checks**

**Pattern:** Check if window meets a condition.

**Examples:**

* All unique characters
* Contains all chars of a pattern
* Sum divisible by K

**Visual:**

```
Window "abca" â†’ Not unique (a repeats)
Window "abc" â†’ All unique âœ…
```

---

## **6ï¸âƒ£ Tips / Tricks**

1. Decide **fixed** vs **dynamic** window.
2. Choose data structure:

   * Counter/Map â†’ for frequency
   * Queue/Deque â†’ for max/min
   * Integer â†’ for sum/product
3. Update window **incrementally**:

   * Add new element
   * Remove old element
4. Collect results at each step if needed.

---

ğŸ’¡ **Memory Hook:**

> â€œFixed = Sum/Max, Dynamic = Condition, Map = Frequency, Deque = Extremesâ€

---



