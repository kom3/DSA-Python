# üîπ Sliding Window Technique (From Zero ‚Üí FAANG)

## 1Ô∏è‚É£ Why Sliding Window Exists (Very Important)

### The problem it solves

Many problems ask:

> ‚ÄúFind something **contiguous** in an array or string‚Äù

Examples:

* Maximum sum subarray of size `k`
* Longest substring without repeating characters
* Smallest subarray with sum ‚â• `X`

### Naive (Brute Force) Thinking

For every possible subarray:

* Calculate its sum / count / condition
* Time complexity: **O(n¬≤)** ‚ùå (too slow for FAANG)

üëâ **Sliding Window reduces this to O(n)**

---

## 2Ô∏è‚É£ What Is a Sliding Window?

Imagine a **window** (range) that moves over the array:

```
[ 2  1  5  1  3  2 ]
  ‚Üë     ‚Üë
 left  right
```

Instead of recomputing everything:

* **Add** the new element entering the window
* **Remove** the element leaving the window

This saves time.

---

## 3Ô∏è‚É£ Two Types of Sliding Window (MUST KNOW)

### üîπ Type 1: Fixed Size Window

Window size is constant (`k`)

Examples:

* Maximum sum of subarray of size `k`
* Average of subarrays of size `k`

### üîπ Type 2: Variable Size Window

Window expands and shrinks based on conditions

Examples:

* Longest substring without repeating characters
* Smallest subarray with sum ‚â• target

---

## 4Ô∏è‚É£ Fixed Size Sliding Window (FOUNDATION)

### Example Problem

**Maximum sum of subarray of size `k`**

#### Input:

```
nums = [2, 1, 5, 1, 3, 2]
k = 3
```

#### Brute Force ‚ùå

Check all subarrays of size 3 ‚Üí O(nk)

---

### Optimal Sliding Window ‚úÖ

#### Intuition

1. Calculate sum of first `k` elements
2. Slide window:

   * Add next element
   * Remove previous element

---

### ‚úÖ Code (Python)

```python
def max_sum_subarray(nums, k):
    window_sum = 0
    max_sum = 0

    for i in range(len(nums)):
        window_sum += nums[i]     # add element

        if i >= k - 1:
            max_sum = max(max_sum, window_sum)
            window_sum -= nums[i - (k - 1)]  # remove element

    return max_sum
```

---

### ‚è± Time & Space

* Time: **O(n)**
* Space: **O(1)**

---

## 5Ô∏è‚É£ Variable Size Sliding Window (FAANG FAVORITE)

### Example Problem

**Longest Substring Without Repeating Characters**

```
Input: "abcabcbb"
Output: 3  ("abc")
```

---

### Key Idea

* Expand `right` pointer
* If condition breaks ‚Üí shrink from `left`

---

### üß† Window Rules

| Step    | Action        |
| ------- | ------------- |
| Expand  | Move `right`  |
| Invalid | Shrink `left` |
| Valid   | Update answer |

---

### ‚úÖ Code (Python)

```python
def longest_unique_substring(s):
    char_set = set()
    left = 0
    max_len = 0

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1

        char_set.add(s[right])
        max_len = max(max_len, right - left + 1)

    return max_len
```

---

### üî• Interview Insight

* `right - left + 1` ‚Üí current window size
* Shrinking ensures condition is valid

---

## 6Ô∏è‚É£ Universal Sliding Window Template (MEMORIZE)

```python
left = 0

for right in range(n):
    # expand window
    add(nums[right])

    while window_invalid:
        remove(nums[left])
        left += 1

    update_answer()
```

üî• **90% of sliding window problems follow this**

---

## 7Ô∏è‚É£ FAANG Sliding Window Patterns

### Common Questions

| Pattern          | Example              |
| ---------------- | -------------------- |
| Max/Min Subarray | Max sum of size k    |
| Longest Window   | Longest substring    |
| Smallest Window  | Min window substring |
| Count Windows    | Number of subarrays  |

---

## 8Ô∏è‚É£ Interview Red Flags üö©

‚ùå Nested loops for subarrays
‚ùå Recomputing sum every time
‚ùå Forgetting to shrink window

---

## 9Ô∏è‚É£ Practice Problems (In Order)

### Beginner

1. Maximum sum subarray of size k
2. Average of subarrays of size k

### Intermediate

3. Longest substring without repeating characters
4. Longest subarray with sum ‚â§ k

### Advanced (FAANG)

5. Minimum Window Substring
6. Subarrays with exactly K distinct integers

---

## 10Ô∏è‚É£ What We Will Learn Next

* **Prefix Sum vs Sliding Window**
* **Hard FAANG problem walkthrough**
* **Sliding Window + HashMap**
* **Mock interview on Sliding Window**

---

# 1Ô∏è‚É£ Prefix Sum vs Sliding Window (CRITICAL COMPARISON)

Many students confuse these. FAANG interviewers **expect you to choose correctly**.

---

## üîπ Prefix Sum ‚Äî WHEN & WHY

### What is Prefix Sum?

Prefix sum stores **cumulative information**.

```python
prefix[i] = sum(nums[0] ‚Üí nums[i])
```

### Why it works

It allows **O(1)** range queries after **O(n)** preprocessing.

---

### Example Use Case

üëâ *‚ÄúFind number of subarrays with sum = K‚Äù*
üëâ *Negative numbers allowed*

‚ùå Sliding window FAILS here
‚úÖ Prefix sum + HashMap works

---

### Example Code

```python
def subarraySum(nums, k):
    count = 0
    prefix_sum = 0
    mp = {0: 1}

    for num in nums:
        prefix_sum += num
        if prefix_sum - k in mp:
            count += mp[prefix_sum - k]
        mp[prefix_sum] = mp.get(prefix_sum, 0) + 1

    return count
```

---

## üîπ Sliding Window ‚Äî WHEN & WHY

### Works ONLY when:

* Subarray is **contiguous**
* Condition becomes valid by **shrinking window**
* Usually **positive numbers / monotonic behavior**

---

### Example Use Case

üëâ Longest substring without repeating characters
üëâ Maximum sum subarray of size K

---

## üî• Interview Comparison Table (MEMORIZE)

| Scenario                             | Use            |
| ------------------------------------ | -------------- |
| Fixed window size                    | Sliding Window |
| Longest / shortest subarray          | Sliding Window |
| Negative numbers                     | Prefix Sum     |
| Count subarrays                      | Prefix Sum     |
| Window condition breaks by shrinking | Sliding Window |

---

# 2Ô∏è‚É£ Sliding Window + HashMap (VERY IMPORTANT)

Most **hard FAANG problems** use this combo.

---

## Core Idea

* Window = two pointers
* HashMap = frequency count

---

## Classic Problem

### üî• Longest Substring with At Most K Distinct Characters

---

### Intuition

* Expand `right`
* Count chars in hashmap
* If distinct > K ‚Üí shrink from `left`

---

### Code

```python
def longestSubstringKDistinct(s, k):
    left = 0
    freq = {}
    max_len = 0

    for right in range(len(s)):
        freq[s[right]] = freq.get(s[right], 0) + 1

        while len(freq) > k:
            freq[s[left]] -= 1
            if freq[s[left]] == 0:
                del freq[s[left]]
            left += 1

        max_len = max(max_len, right - left + 1)

    return max_len
```

---

## Interview Insight üîç

* HashMap tracks **window validity**
* Length = `right - left + 1`
* This pattern appears in **Google, Meta, Amazon**

---

# 3Ô∏è‚É£ HARD FAANG PROBLEM WALKTHROUGH üî•

## üß† Problem: Minimum Window Substring (LeetCode Hard)

### Given:

```
s = "ADOBECODEBANC"
t = "ABC"
```

### Output:

```
"BANC"
```

---

## Why this is HARD

* Variable window
* Exact frequency matching
* Shrinking window carefully

---

## Strategy (VERY IMPORTANT)

### Data Structures:

* `need` ‚Üí frequency of chars in `t`
* `window` ‚Üí current window frequency
* `formed` ‚Üí matched characters count

---

### Code (Interview-Ready)

```python
from collections import Counter

def minWindow(s, t):
    need = Counter(t)
    window = {}
    have = 0
    need_count = len(need)

    left = 0
    res = [-1, -1]
    res_len = float("inf")

    for right in range(len(s)):
        char = s[right]
        window[char] = window.get(char, 0) + 1

        if char in need and window[char] == need[char]:
            have += 1

        while have == need_count:
            if (right - left + 1) < res_len:
                res = [left, right]
                res_len = right - left + 1

            window[s[left]] -= 1
            if s[left] in need and window[s[left]] < need[s[left]]:
                have -= 1
            left += 1

    l, r = res
    return s[l:r+1] if res_len != float("inf") else ""
```

---

## What Interviewer Is Testing

‚úÖ Can you track frequencies
‚úÖ Can you shrink optimally
‚úÖ Can you explain invariants

---

# 4Ô∏è‚É£ MOCK INTERVIEW (REALISTIC)

### üé§ Interviewer:

> Solve: *Longest Substring Without Repeating Characters*

---

### ‚úÖ Perfect Answer Structure

#### Step 1: Clarify

* String
* Return length
* Case sensitive?

#### Step 2: Brute Force

* O(n¬≤)
* Explain inefficiency

#### Step 3: Optimal Approach

* Sliding window + set
* Two pointers

#### Step 4: Code

(You already know it)

---

### üî• What Gets You Selected

‚úî Explaining window logic
‚úî Correct shrinking condition
‚úî Clean O(n) solution

---

## 5Ô∏è‚É£ Final Sliding Window Master Template (FAANG GOLD)

```python
left = 0
window = {}

for right in range(n):
    add(nums[right])

    while condition_breaks:
        remove(nums[left])
        left += 1

    update_answer()
```

