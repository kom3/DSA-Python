# ğŸ“˜ Lecture 1: What Is a Prefix Sum?

### Problem with brute force

Suppose you have an array:

```
nums = [2, 4, 6, 8]
```

Youâ€™re asked many times:

> â€œWhat is the sum from index `i` to `j`?â€

Brute force:

```text
Sum(i, j) = nums[i] + nums[i+1] + ... + nums[j]
```

â± Time: **O(n)** per query
âŒ Too slow if there are many queries

---

### ğŸ’¡ Key Idea (Prefix Sum)

Instead of recomputing sums again and again, **precompute cumulative sums**.

---

# ğŸ“— Prefix Sum Definition

Let:

```
prefix[i] = sum of elements from index 0 to i-1
```

We define:

```
prefix[0] = 0
prefix[i] = prefix[i-1] + nums[i-1]
```

For `nums = [2, 4, 6, 8]`:

| i | prefix[i] |
| - | --------- |
| 0 | 0         |
| 1 | 2         |
| 2 | 6         |
| 3 | 12        |
| 4 | 20        |

---

### ğŸ”‘ Why this helps

Sum from index `l` to `r`:

```
sum(l, r) = prefix[r+1] - prefix[l]
```

â± Time per query: **O(1)**
â± Preprocessing: **O(n)**

---

# ğŸ§  Core Insight (FAANG loves this)

> **Prefix sum converts repeated range calculations into constant-time queries**

---

# ğŸ“˜ Lecture 2: Prefix Sum Patterns

There are **4 major patterns** you must master:

---

## 1ï¸âƒ£ Range Sum Queries

ğŸ‘‰ Most basic usage

Used when:

* Many sum queries
* Array doesnâ€™t change

---

## 2ï¸âƒ£ Prefix Sum + HashMap

ğŸ‘‰ Used to count subarrays with a condition

Key formula:

```
If prefix[j] - prefix[i] = K
Then prefix[i] = prefix[j] - K
```

This unlocks **subarray problems**.

---

## 3ï¸âƒ£ 2D Prefix Sum

ğŸ‘‰ Used in matrices

```
sum of submatrix in O(1)
```

Very common in Google / Amazon.

---

## 4ï¸âƒ£ Difference Array (Reverse Prefix)

ğŸ‘‰ Used for range updates efficiently

---

Prefix-sum problems show up **a lot**, and the way you **initialize the hash map** depends on *what youâ€™re trying to detect*. Below is a **clean cheat-sheet** with **patterns + examples** so you can recognize them instantly in interviews.

---

## 1ï¸âƒ£ `{0: 1}` â†’ **Counting subarrays**

### Use when:

You are asked **â€œhow many subarraysâ€** satisfy a condition.

### Why:

* Prefix sum `0` has occurred **once before starting**.
* Helps count subarrays that start at index `0`.

### Example problem:

**Subarray Sum Equals K (LC 560)**

```python
count = 0
prefix_sum = 0
freq = {0: 1}

for num in nums:
    prefix_sum += num
    if prefix_sum - k in freq:
        count += freq[prefix_sum - k]
    freq[prefix_sum] = freq.get(prefix_sum, 0) + 1
```

ğŸ“Œ **Rule**:

> Use `{0: 1}` when **counting** subarrays.

---

## 2ï¸âƒ£ `{0: -1}` â†’ **Checking existence + length**

### Use when:

You are asked **â€œdoes a subarray existâ€** and need **minimum length â‰¥ 2**.

### Why:

* Index `-1` represents prefix sum before array starts.
* Makes length calculation easy: `i - j`.

### Example problem:

**Continuous Subarray Sum (LC 523)**

```python
remainder_index = {0: -1}
prefix_sum = 0

for i, num in enumerate(nums):
    prefix_sum += num
    prefix_sum %= k

    if prefix_sum in remainder_index:
        if i - remainder_index[prefix_sum] >= 2:
            return True
    else:
        remainder_index[prefix_sum] = i
```

ğŸ“Œ **Rule**:

> Use `{0: -1}` when **checking existence** with **length constraint**.

---

## 3ï¸âƒ£ `{}` (empty map) â†’ **First occurrence tracking**

### Use when:

You only care about the **first time** a prefix sum appears.

### Example problem:

**Longest subarray with sum = K**

```python
prefix_sum = 0
first_index = {}
max_len = 0

for i, num in enumerate(nums):
    prefix_sum += num

    if prefix_sum == k:
        max_len = i + 1

    if prefix_sum - k in first_index:
        max_len = max(max_len, i - first_index[prefix_sum - k])

    if prefix_sum not in first_index:
        first_index[prefix_sum] = i
```

ğŸ“Œ **Rule**:

> Empty map when **index 0 is handled separately**.

---

## 4ï¸âƒ£ `{0: 0}` â†’ **Prefix arrayâ€“style logic**

### Use when:

You are treating prefix sums like a **1-based array**.

### Why:

* Prefix sum at position 0 is considered valid.
* More common in math-heavy or 1-based indexing logic.

```python
prefix_index = {0: 0}
```

ğŸ“Œ Less common in LeetCode, but useful in theory problems.

---

## 5ï¸âƒ£ `{}` + special check for index 0

### Use when:

You want **manual control** instead of pre-filling the map.

### Example:

```python
prefix_sum = 0
seen = {}

for i, num in enumerate(nums):
    prefix_sum += num

    if prefix_sum == k and i >= 1:
        return True

    if prefix_sum in seen:
        if i - seen[prefix_sum] >= 2:
            return True
    else:
        seen[prefix_sum] = i
```

ğŸ“Œ More verbose, less elegant, but sometimes clearer for beginners.

---

## ğŸ§  Master Cheat Sheet (Memorize This)

| Goal                         | Map Initialization |
| ---------------------------- | ------------------ |
| Count subarrays              | `{0: 1}`           |
| Check existence (length â‰¥ 2) | `{0: -1}`          |
| Longest subarray             | `{}`               |
| Prefix array logic           | `{0: 0}`           |
| Manual handling              | `{}` + checks      |

---



# ğŸŸ¢ Beginner LeetCode-Level Problems

---

## ğŸŸ¢ Problem 1: Range Sum Query â€“ Immutable

**Concept tested:** Basic prefix sum

### Idea

* Build prefix array once
* Answer queries in O(1)

### Pseudocode

```python
prefix[0] = 0
for i in range(n):
    prefix[i+1] = prefix[i] + nums[i]

sum(l, r) = prefix[r+1] - prefix[l]
```

ğŸ’¡ **Interview expectation:**
You should instantly recognize prefix sum.

---

## ğŸŸ¢ Problem 2: Running Sum of 1D Array

**Concept tested:** Understanding prefix accumulation

Simple:

```python
running[i] = running[i-1] + nums[i]
```

âš ï¸ Trick: Youâ€™re *building* the prefix array directly.

---

# ğŸŸ¡ Intermediate LeetCode-Level Problems

Now we enter **real interview territory**.

---

## ğŸŸ¡ Problem 3: Subarray Sum Equals K

ğŸ”¥ **VERY IMPORTANT**

### Problem type

Count number of subarrays whose sum = K.

---

### âŒ Brute Force

* All subarrays
* O(nÂ²)

---

### âœ… Prefix Sum + HashMap

Let:

```
current_sum = prefix[j]
We want: prefix[j] - prefix[i] = K
â†’ prefix[i] = prefix[j] - K
```

So:

* Store frequencies of prefix sums
* For each new prefix, check if `current_sum - K` exists

---

### Algorithm

```python
count = 0
prefix_sum = 0
map = {0: 1}

for num in nums:
    prefix_sum += num
    if prefix_sum - k in map:
        count += map[prefix_sum - k]
    map[prefix_sum] += 1
```

â± Time: **O(n)**
ğŸ”¥ FAANG favorite

---

## ğŸŸ¡ Problem 4: Find Pivot Index

**Concept tested:** Total sum vs prefix sum

Condition:

```
left_sum == total_sum - left_sum - nums[i]
```

Very common logic test.

---

# ğŸ”´ Hard LeetCode-Level Problems

Now we reach **senior interview level**.

---

## ğŸ”´ Problem 5: Maximum Size Subarray Sum Equals K

**Concept tested:** Prefix sum + first occurrence

### Key trick

* Store **first index** where a prefix sum appears
* Maximize `(current_index - first_index)`

---

### Core logic

```python
if prefix_sum - k in map:
    max_len = max(max_len, i - map[prefix_sum - k])
```

---

## ğŸ”´ Problem 6: Submatrix Sum Equals Target (2D Prefix Sum)

ğŸ”¥ Extremely important

---

### 2D Prefix Sum Formula

```
prefix[r][c] =
matrix[r][c]
+ prefix[r-1][c]
+ prefix[r][c-1]
- prefix[r-1][c-1]
```

---

### Strategy

1. Fix two rows
2. Compress columns into 1D array
3. Use **Subarray Sum = K** logic

â± Time: **O(rowsÂ² Ã— cols)**
ğŸ’¼ Asked at Google / Meta

---

# ğŸ§  How FAANG Evaluates You

They check if:

* You recognize prefix sum **immediately**
* You combine it with hash maps
* You reduce time complexity
* You explain the math clearly

---

# ğŸ¯ Final Mental Checklist

When you see:

* **Range sum** â†’ Prefix Sum
* **Subarray with sum** â†’ Prefix + HashMap
* **2D matrix sum** â†’ 2D Prefix
* **Multiple updates** â†’ Difference Array

---

Hereâ€™s a curated list of **LeetCode problems for practicing the Prefix Sum pattern**, organized by **Beginner (Easy)**, **Medium**, and **Hard** categories. Prefix sum (including prefixâ€‘sum + hashmap techniques) helps solve range sum queries, subarray count/difference problems, and more efficiently than brute force. ([LeetCode][1])

---

## ğŸŸ¢ Beginner / Easy (Great for Getting Started)

1. **Running Sum of 1d Array** â€” straightforward prefix sum construction
   ğŸ”— [https://leetcode.com/problems/running-sum-of-1d-array/](https://leetcode.com/problems/running-sum-of-1d-array/)
2. **Range Sum Query â€“ Immutable** (#303) â€” basic range sum with prefix array
   ğŸ”— [https://leetcode.com/problems/range-sum-query-immutable/](https://leetcode.com/problems/range-sum-query-immutable/) ([leetcodethehardway.com][2])
3. **Find Pivot Index** (#724) â€” use prefix sums to find index where left sum = right sum
   ğŸ”— [https://leetcode.com/problems/find-pivot-index/](https://leetcode.com/problems/find-pivot-index/) ([leetcodethehardway.com][3])
4. **Sum of All Odd Length Subarrays** (#1588) â€” count subarrays via prefix sums
   ğŸ”— [https://leetcode.com/problems/sum-of-all-odd-length-subarrays/](https://leetcode.com/problems/sum-of-all-odd-length-subarrays/) ([leetcodethehardway.com][3])
5. **Maximum Average Subarray I** (#643) â€” sliding window related but often presented with prefix sum exploration
   ğŸ”— [https://leetcode.com/problems/maximum-average-subarray-i/](https://leetcode.com/problems/maximum-average-subarray-i/)

ğŸ“Œ *Why these are good:* They focus on prefix sums basics â€” building the cumulative array and answering simple queries. ([LeetCopilot][4])

---

## ğŸ”µ Medium (Core Prefix Sum Challenges)

1. **Subarray Sum Equals K** (#560) â€” count subarrays with sum = k using prefix sum + hashmap
   ğŸ”— [https://leetcode.com/problems/subarray-sum-equals-k/](https://leetcode.com/problems/subarray-sum-equals-k/) ([LeetCode][1])
2. **Continuous Subarray Sum** (#523) â€” check for subarray sum multiple of k
   ğŸ”— [https://leetcode.com/problems/continuous-subarray-sum/](https://leetcode.com/problems/continuous-subarray-sum/) ([LeetCode][1])
3. **Maximum Size Subarray Sum Equals k** (#325) â€” longest subarray with sum k (prefix + hashmap)
   ğŸ”— [https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/) ([LeetCode][1])
4. **Subarray Sums Divisible by K** (#974) â€” count subarrays with sum mod k == 0
   ğŸ”— [https://leetcode.com/problems/subarray-sums-divisible-by-k/](https://leetcode.com/problems/subarray-sums-divisible-by-k/) ([leetcodethehardway.com][2])
5. **Binary Subarrays With Sum** (#930) â€” number of subarrays with a fixed number of ones
   ğŸ”— [https://leetcode.com/problems/binary-subarrays-with-sum/](https://leetcode.com/problems/binary-subarrays-with-sum/) ([LeetCode][1])
6. **Contiguous Array** (#525) â€” find longest equal 0s & 1s subarray (prefix + hashmap)
   ğŸ”— [https://leetcode.com/problems/contiguous-array/](https://leetcode.com/problems/contiguous-array/) ([leetcodethehardway.com][3])
7. **Count Number of Nice Subarrays** (#1248) â€” count subarrays with k odd numbers
   ğŸ”— [https://leetcode.com/problems/count-number-of-nice-subarrays/](https://leetcode.com/problems/count-number-of-nice-subarrays/) ([LeetCode][1])

ğŸ“Œ *Why these are Medium:* They require combining prefix sums with hashmaps or clever logic to count or find longest subarrays. ([LeetCopilot][4])

---

## ğŸ”´ Hard (Advanced Prefix Sum Variants)

1. **Number of Submatrices That Sum to Target** (#1074) â€” 2D prefix sums + hashmap
   ğŸ”— [https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/) ([LeetCode][1])
2. **Max Sum of Rectangle No Larger Than K** (#363) â€” hard 2D prefix + optimization
   ğŸ”— [https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/) ([LeetCode][1])
3. **Range Sum Query 2D â€“ Immutable** (#304) â€” 2D prefix sum queries
   ğŸ”— [https://leetcode.com/problems/range-sum-query-2d-immutable/](https://leetcode.com/problems/range-sum-query-2d-immutable/) ([leetcodethehardway.com][3])
4. **Sum of Prefix Scores of Strings** (#2416) â€” hard problem with prefixâ€‘based scoring logic
   ğŸ”— [https://leetcode.com/problems/sum-of-prefix-scores-of-strings/](https://leetcode.com/problems/sum-of-prefix-scores-of-strings/) ([Leetcode][5])

ğŸ“Œ *Why these are Hard:* They extend prefix sum concepts into 2D or combine with other patterns (Kadaneâ€™s, hashmap + geometry). ([LeetCopilot][4])

---

## ğŸ“Œ Tips for Practicing Prefix Sum

âœ” Start with basic 1D prefix arrays before moving to hashmap-based subarray counting. ([LeetCopilot][4])
âœ” When negative numbers appear or counts/lengths are needed, think prefix sum + hashmap. ([LeetCopilot][4])
âœ” For matrices, learn the 2D prefix sum inclusion-exclusion technique. ([LeetCopilot][4])

---